package provider

import (
	"crypto"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/ProtonMail/go-crypto/openpgp"
	"github.com/ProtonMail/go-crypto/openpgp/armor"
	"github.com/ProtonMail/go-crypto/openpgp/packet"
)

func resourcePgpPrivateKey() *schema.Resource {
	return &schema.Resource{
		Description: "Pgp private key, generated by converting an existing private key passed in pem format.",
		Create: resourcePgpPrivateKeyCreate,
		Read:   resourcePgpPrivateKeyRead,
		Delete: resourcePgpPrivateKeyDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"private_key": {
				Description: "Private key to convert in pem format.",
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			"algorithm": {
				Description: "Algorithm of the encryption. The following values are currently supported: rsa.",
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "rsa",
				ForceNew:     true,
				ValidateFunc: func(val interface{}, key string) (warns []string, errs []error) {
					v := val.(string)
					if v != "rsa" {
						return []string{}, []error{errors.New("Permitted value for algorithm can only be one of the following: rsa.")}
					}

					return []string{}, []error{}
				},
			},
			"timestamp": {
				Description: "Timestamp needed by pgp.",
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validation.IsRFC3339Time,
			},
			"name": {
				Description: "Name to associate with the gpg key.",
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			"email": {
				Description: "Email to associate with the gpg key.",
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			"public_key_gpg_armor": &schema.Schema{
				Description: "Public key in gpg armor format.",
				Type:     schema.TypeString,
				Computed: true,
			},
			"private_key_gpg_armor": &schema.Schema{
				Description: "Private key in gpg armor format.",
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func GetParsedKeyFromPemFormat(privatePemKey string) (any, error) {
	priBlock, _ := pem.Decode([]byte(privatePemKey))
	if priBlock == nil || priBlock.Type != "PRIVATE KEY" {
		return nil, errors.New("Failed to decode pem encoded private_key.")
	}

	key, keyErr := x509.ParsePKCS8PrivateKey(priBlock.Bytes)
	if keyErr != nil {
		return nil, errors.New(fmt.Sprintf("Failed to parse private_key: %s.", keyErr.Error()))
	}

	return key, nil
}

func GetOpenPgpEntityFromParsedKey(key any, algorithm string, name string, email string, timestamp time.Time) (*openpgp.Entity, *packet.Config, error) {
	config := &packet.Config{DefaultHash: crypto.SHA256}
	entity, entityErr := openpgp.NewEntity(name, "", email, config)
	if entityErr != nil {
		return nil, nil, errors.New(fmt.Sprintf("Failed to build formated keys: %s.", entityErr.Error()))
	}

	if algorithm == "rsa" {
		rsaKey := key.(*rsa.PrivateKey)
		rsaPubKey := rsaKey.Public().(*rsa.PublicKey)
		entity.PrimaryKey = packet.NewRSAPublicKey(timestamp, rsaPubKey)
		entity.PrivateKey = packet.NewRSAPrivateKey(timestamp, rsaKey)
	}

	for _, id := range entity.Identities {
		signatureErr := id.SelfSignature.SignUserId(id.UserId.Id, entity.PrimaryKey, entity.PrivateKey, config)
		if signatureErr != nil {
			return nil, nil, errors.New(fmt.Sprintf("Failed to self sign identity: %s.", signatureErr.Error()))
		}
	}

	return entity, config, nil
} 

type GpgEncoderWriter struct {
	EncodedValue string
}

func (writer *GpgEncoderWriter) Write(p []byte) (n int, err error) {
	writer.EncodedValue += string(p)
	return len(p), nil
}

func GetArmorEncodedKeyFromEntity(entity *openpgp.Entity, config *packet.Config, private bool) (string, error) {
	keyType := openpgp.PublicKeyType
	keyMsgString := "public"
	if private {
		keyType = openpgp.PrivateKeyType
		keyMsgString = "private"
	}

	encKey := GpgEncoderWriter{}
	keyWriter, encodeErr := armor.Encode(&encKey, keyType, nil)
	if encodeErr != nil {
		return "", errors.New(fmt.Sprintf("Failed to encode %s key in gpg armor format: %s.", keyMsgString, encodeErr.Error()))
	}

	var serErr error
	if !private {
		serErr = entity.Serialize(keyWriter)
	} else {
		serErr = entity.SerializePrivate(keyWriter, config)
	}

	if serErr != nil {
		return "", errors.New(fmt.Sprintf("Failed to encode %s key in gpg armor format: %s.", keyMsgString, serErr.Error()))
	}

	closeErr := keyWriter.Close()
	if closeErr != nil {
		return "", errors.New(fmt.Sprintf("Failed to encode %s key in gpg armor format: %s.", keyMsgString, closeErr.Error()))
	}

	return encKey.EncodedValue, nil
}

func resourcePgpPrivateKeyCreate(d *schema.ResourceData, meta interface{}) error {
	privateKeyPem := d.Get("private_key").(string)
	algorithm := d.Get("algorithm").(string)
	timestamp := d.Get("timestamp").(string)
	name := d.Get("name").(string)
	email := d.Get("email").(string)

	parsedTimestamp, timeerr := time.Parse(time.RFC3339, timestamp)
	if timeerr != nil {
		return errors.New(fmt.Sprintf("Failed to parse timestamp: %s.", timeerr.Error()))
	}

	key, keyErr := GetParsedKeyFromPemFormat(privateKeyPem)
	if keyErr != nil {
		return keyErr
	}

	entity, config, entityErr := GetOpenPgpEntityFromParsedKey(key, algorithm, name, email, parsedTimestamp)
	if entityErr != nil {
		return entityErr
	}

	priKey, priKeyErr := GetArmorEncodedKeyFromEntity(entity, config, true)
	if priKeyErr != nil {
		return priKeyErr
	}

	pubKey, pubKeyErr := GetArmorEncodedKeyFromEntity(entity, config, false)
	if pubKeyErr != nil {
		return pubKeyErr
	}

	d.Set("private_key_gpg_armor", priKey)
	d.Set("public_key_gpg_armor", pubKey)
	d.SetId(pubKey)

	return nil
}

func resourcePgpPrivateKeyRead(d *schema.ResourceData, meta interface{}) error {
	return nil
}

func resourcePgpPrivateKeyDelete(d *schema.ResourceData, meta interface{}) error {
	return nil
}